<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blog on</title><link>https://go-goim.github.io/blog/</link><description>Recent content in Blog on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Tue, 06 Oct 2020 08:49:55 +0000</lastBuildDate><atom:link href="https://go-goim.github.io/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>实现异步并发 worker 队列</title><link>https://go-goim.github.io/blog/worker-pool/</link><pubDate>Mon, 11 Apr 2022 09:19:42 +0100</pubDate><guid>https://go-goim.github.io/blog/worker-pool/</guid><description>前言 # 以往遇到类似的问题我都会借助 sync.WaitGroup 加 channel 的方式去做，实现方式也比较简单。大致思路如下：
1type LimitedWaitGroup struct { 2 wg *sync.WaitGroup 3 ch chan int 4} 5 6func NewLimitedWaitGroup(size int) *LimitedWaitGroup { 7 return &amp;amp;LimitedWaitGroup{ 8 wg : new(sync.WaitGroup), 9 ch : make(chan int, size) 10 } 11} 12 13func (w *LimitedWaitGroup) Add(f func()) { 14 // wait if channel is full 15 w.ch &amp;lt;- 1 16 w.wg.Add(1) 17 go func() { 18 defer w.done() 19 f() 20 }() 21} 22 23func (w *LimitedWaitGroup) done() { 24 &amp;lt;-w.</description></item><item><title>推送服务开发过程的问题总结</title><link>https://go-goim.github.io/blog/push-server-summarize/</link><pubDate>Fri, 10 Jun 2022 09:19:42 +0800</pubDate><guid>https://go-goim.github.io/blog/push-server-summarize/</guid><description>前言 事件管理 连接管理 消息推送 总结 前言 # push server 的开发是在做 goim 的前期的重头戏,其核心就是长链接(本次用 websocket)的管理和与业务相互结合.
websocket 算是一个比较久远成熟的长链接方案况且有成熟的框架(本项目使用的 gorilla/websocket)支持,按理来说,它的使用应该是比较简单的,但是它的使用过程中,有一些问题和挑战,这里做一个总结.
而遇到的问题大部分是在使用和与业务的整合上,大致分为一下几点:
事件管理(如 ping pong,心跳,消息等) 连接管理 消息推送 事件管理 # 在建立起连接之后,需要对一些 ws 消息类型做不同的处理,如 ping/pong 时,连接管理层面刷新一些连接最后活跃时间已确保连接可用,而业务层面需要对该连接对应的用户 的 last_online_time 信息进行刷新动作,又比如 close 事件也是连接管理层面和业务层面各自需要做处理.
虽说框架提供了注册事件处理器的机制,但是不足以满足需求.连接层是纯粹管理长链接不依赖业务逻辑（且连接层与业务是分开的项目代码），因此没办法在连接层直接引入逻辑层的逻辑去注册相关处理函数。而业务层虽说可以引入连接层的逻辑，但是不同业务处理的方式不一样很难统一管理。
以下为原始注册方法，只能注册单个方法，如果需要有多个处理函数则需要手动嵌套：
1// 连接层注册连接层的事件处理器 2conn.SetCloseHandler(func(code int, text string) error { 3 wc.cancelWithError(nil) 4 message := websocket.FormatCloseMessage(code, &amp;#34;&amp;#34;) 5 _ = wc.conn.WriteControl(websocket.CloseMessage, message, time.Now().Add(time.Second)) 6 return nil 7}) 8 9conn.SetPingHandler(func(message string) error { 10 err := c.</description></item></channel></rss>