<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blog on</title><link>https://go-goim.github.io/blog/</link><description>Recent content in Blog on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Tue, 06 Oct 2020 08:49:55 +0000</lastBuildDate><atom:link href="https://go-goim.github.io/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>实现异步并发 worker 队列</title><link>https://go-goim.github.io/blog/%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91-worker-%E9%98%9F%E5%88%97/</link><pubDate>Mon, 11 Apr 2022 09:19:42 +0100</pubDate><guid>https://go-goim.github.io/blog/%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91-worker-%E9%98%9F%E5%88%97/</guid><description>前言 # 以往遇到类似的问题我都会借助 sync.WaitGroup 加 channel 的方式去做，实现方式也比较简单。大致思路如下：
1type LimitedWaitGroup struct { 2 wg *sync.WaitGroup 3 ch chan int 4} 5 6func NewLimitedWaitGroup(size int) *LimitedWaitGroup { 7 return &amp;amp;LimitedWaitGroup{ 8 wg : new(sync.WaitGroup), 9 ch : make(chan int, size) 10 } 11} 12 13func (w *LimitedWaitGroup) Add(f func()) { 14 // wait if channel is full 15 w.ch &amp;lt;- 1 16 w.wg.Add(1) 17 go func() { 18 defer w.done() 19 f() 20 }() 21} 22 23func (w *LimitedWaitGroup) done() { 24 &amp;lt;-w.</description></item></channel></rss>